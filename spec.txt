// Mars programming language (.mars ?)
// C lang simple featureless clone, rust-like look

// primitives
    void
    bool
    char
    f64
    i64
    
    [type; size]    // array

    // temporarily refusing
    &_              // mut ptr
    &i32  &MemorySth
    

// variables

    var x: i32 = 0
    var arr: [i32; 3] = [4; 3]      // [4, 4, 4]
    var ara: [i32; 3] = [1, 2, 3]   // [1, 2, 3]
    var str: String = "hello"
    
// operations

    // appropriate
    =

    // deref (temporarily refusing)
    *

    // math
    +
    -
    *
    /
    
    // comparison
    ==
    !=
    <=
    >=
    >
    <
    

// it would be better not to have semicolens (;) in the and of line

// does not have classes and oop (too hard to implement)
// should have template classes

// structs

struct Hello {
    hello: i64,
    sth_else: f64,
}

impl Hello {
    fun hello() -> void {
        print("hello")
    }

    fun sth(
        a: i64,
        b: i64,
        f: fun(x: i64, y: i64) -> i64) -> i64 {

        return f(a, b)
    }
}


// functions

no typeclasses for functions
simple types

function type: fun (i32, i32) -> i32

fun min(a: i32, b: i32) -> i32 {
    if a < b {
        return a
    } else {
        return b 
    }
}

fun overflow_sum(start: i32) -> void {
    overflow_sum(start + 1)
}

var func: fun(i32) -> void = overflow_sum;




// main()

fun main() -> void {

}


// loops

base: 
    loop {
        if x == y { break }
        else { continue }
    }
    
above it:
    for, while
    
    // bool operation
    while x > y {
        ...
    }
    
    // think about beautiful for and does we need it


// output

var a = 10
var c = 'h'
print("base string" + "digit: " + a + " and char: " + c)


fun pow(base: f64, exp: f64) -> f64 {
    result = 1
    if exp < 0 {
        base = 1 / base
        exponent = -exponent
    }

    for (var i = 0; i < exp; i = i + 1) {
        result = result * base
    }

    return result
}

fun modulo(dividend: i64, divisor: i64) -> f64 {
    var quotient = dividend / divisor
    return dividend - (quotient * divisor)
}