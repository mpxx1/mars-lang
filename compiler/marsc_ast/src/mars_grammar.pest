program      = _{ SOI ~ ( stmt )* ~ EOI }
stmt         = _{ NEWLINE | break | comment | struct_decl |
                  assigment | assign | expr }

WHITESPACE   = _{ " " | "\t" | "\r" | "\n" }

break        =  { "break" }

comment      = _{ multi_line_comment }
multi_line_comment = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

identifier   = @{ !"i64" ~ !"f64" ~ !"u8" ~ !"str" ~ !"char" ~ !"bool" ~ !"fn" ~
                  ( ASCII_ALPHA ~ ( ASCII_ALPHANUMERIC )* ) }
literal      =  { i64_decl | f64_decl | u8_decl | str_decl | char_decl |
                  bool_decl }
block        =  { stmt* }
type         = _{ ref_type | i64_type | func_type | f64_type | u8_type |
                  str_type | char_type | bool_type | custom_type | array_type }
args_decl    =  { ( identifier ~ ":" ~ type ~ "," )* ~ ( identifier ~ ":" ~ type )? }

f64_decl     =  @{ "-"? ~ (ASCII_DIGIT)+ ~ "." ~ (ASCII_DIGIT)+ }
i64_decl     =  @{ "-"? ~ (ASCII_DIGIT)+ }
u8_decl      =  @{ (ASCII_DIGIT)+ }
str_decl     =  @{ "\"" ~ inner ~"\"" }
char_decl    =  @{ "'" ~ char ~ "'" }
bool_decl    =  @{ "true" | "false" }

array_decl   =   { "[" ~ ( expr ~ "," )* ~ ( expr )? ~ "]" }
array_lookup =   { identifier ~ "[" ~ expr ~ "]" }
array_len    =   { (ASCII_DIGIT)+ }

inner        =  @{ char* }
char         =   { !("\"" | "\\") ~ ANY
                    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
                    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4}) }

i64_type     =  { "i64" }
f64_type     =  { "f64" }
u8_type      =  { "u8"  }
str_type     =  { "str" }
char_type    =  { "char" }
bool_type    =  { "bool" }
custom_type  =  { identifier }
array_type   =  { "[" ~ type ~ ";" ~ array_len ~ "]" }
func_type    =  { "fn" ~ "(" ~ ( type ~ "," )* ~ type? ~ ")" ~ ( "->" ~ return_type )? }
ref_type     =  { "&" ~ type }

func_decl    =  { "fn" ~ identifier ~ "(" ~ args_decl ~ ")" ~ ( "->" ~ return_type )? ~ "{" ~ block ~ "}" }
return_type  =  { type }

struct_decl  =  { "struct" ~ identifier ~ "{" ~ args_decl ~ "}" }

assigment    =  { "var" ~ identifier ~ ( ":" ~ type )? ~ "=" ~ expr }
assign       =  { expr ~ "=" ~ expr }  // first expr can be identifier or array_lookup only

expr         = _{ return | reference | dereference | not | func_call | func_decl |
                  array_decl | array_lookup | struct_init | if_else | loop |
                  logical_expr }

return       =  { "return" ~ expr? }

reference    =  { "&" ~ expr }
dereference  =  { "*" ~ expr }
not          =  { "!" ~ expr }

struct_init  =  { identifier ~ "{" ~ struct_init_args ~ "}" }
struct_field = { identifier }
struct_init_args  =  { ( struct_field ~ ":" ~ expr ~ "," )* ~ ( struct_field ~ ":" ~ expr )? }

func_call    =  { identifier ~ "(" ~ func_args_to_call ~ ")" }
func_args_to_call = { ( expr ~ "," )* ~ ( expr )? }

condition    =  { expr }
if_else      =  { "if" ~ condition ~ "{" ~ block ~ "}" ~
                ( "else" ~ "if" ~ condition ~ "{" ~ block ~ "}" )* ~
                ( "else" ~ "{" ~ block ~ "}" )? }

or_op        =  { "||" }
and_op       =  { "&&" }
equal_op     =  { "==" }
not_equal_op =  { "!=" }
more_eq_op   =  { ">=" }
less_eq_op   =  { "<=" }
more_op      =  { ">"  }
less_op      =  { "<"  }

add_op       =  { "+"  }
sub_op       =  { "-"  }
mul_op       =  { "*"  }
div_op       =  { "/"  }

logical_expr     =  { logical_or_expr }
logical_or_expr  =  { logical_and_expr ~ ( or_op ~ logical_and_expr )* }
logical_and_expr =  { equality_expr ~ ( and_op ~ equality_expr )* }
equality_expr    =  { relational_expr ~ ( ( equal_op | not_equal_op ) ~ relational_expr )* }
relational_expr  =  { additive_expr ~ ( ( more_eq_op | less_eq_op | more_op | less_op ) ~ additive_expr )* }
additive_expr    =  { multiplicative_expr ~ (( add_op | sub_op ) ~ multiplicative_expr )* }
multiplicative_expr = { primary_expr ~ (( mul_op | div_op ) ~ primary_expr )* }
primary_expr     =  { null | literal | identifier | "(" ~ expr ~ ")" }

null             = { "null" }

loop        =  { base_loop }
base_loop   =  { "loop" ~ "{" ~ block ~ "}" }

// todo: while_loop, for_loop
// todo: type casting
// todo: add 1e9 decl ability to f64
// todo: add modules support